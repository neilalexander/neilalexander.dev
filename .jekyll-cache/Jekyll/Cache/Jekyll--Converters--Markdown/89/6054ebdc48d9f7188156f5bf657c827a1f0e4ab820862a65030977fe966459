I"Ó/<p>ICMP, or â€œInternet Control Message Protocolâ€, is a protocol designed to help computers understand when things go wrong out on a network. Itâ€™s a supporting protocol - that is, to say, that IP does not strictly require on ICMP to function, however typical networking devices such as routers and endpoints are expected to speak and understand ICMP. You might also know ICMP thanks to â€œpingâ€, a utility designed to see if a remote computer on a network is alive and connected.Â </p>

<p>You might also know about ICMP from some security guide that you read online which tells you, unwaveringly, to block ICMP traffic. â€œICMP is a security risk,â€ they chorus, â€œyou must filter all ICMP packets from your network!â€</p>

<p>Sadly, there are a staggering number of security professionals who actually know very little about the real working mechanisms of IP (and an even more staggering number that know nothing about Layer 2!) writing articles online and broadcasting this advice with a broken, or altogether missing understanding of what ICMP actually does.Â </p>

<h4 id="so-what-does-icmp-do">So what does ICMP do?</h4>

<p>ICMP is a simple protocol. The packets are usually very small and typically contain a very limited amount of information. They also contain a type code that describes the purpose of the packet - in essence, the message being sent. There are a variety of type codes. ICMP is a bit of a diagnostic utility, and it is a bit of an error-reporting mechanism. Itâ€™s used to tell a network device about a problem in the network when sending an IP packet.</p>

<p>Youâ€™re probably familiar with â€œICMP ECHOâ€, or as itâ€™s known more affectionately, â€œpingâ€. There are other codes that describe â€œICMP DESTINATION UNREACHABLEâ€ (for example, a host is offline, or there is no known route to it) and â€œICMP TTL EXCEEDEDâ€ (the packet went over more hops than it was allowed to - actually, this is very useful for diagnosing routing loops!). Thereâ€™s a code to describe â€œICMP BAD IP HEADERSâ€ for a malformed IP packet, and some more to include information about â€œICMP REDIRECTSâ€ - this packet is no good here, send it there instead.</p>

<p>Network endpoints and routers should generate these ICMP messages as a result of one or more network conditions that may result in a packet not being delivered correctly to itâ€™s destination. That is, if you send a packet to an IP address for which no route exists, expect a router in the path to respond back to you with a â€œdestination unreachableâ€ ICMP message.</p>

<h4 id="what-are-the-consequences-of-blocking-icmp">What are the consequences of blocking ICMP?</h4>

<p>When you block ICMP, you are effectively filtering or dropping these warning packets from being delivered back to the sending endpoint. That IP packet that you sent off before? It never got there, but youâ€™ll never find out about it because the ICMP â€œdestination unreachableâ€ message was discarded before it reached you. Therefore your computer just assumes that nothing went wrong, and it will sit and wait, quite often for a long time, before giving up on expecting a response. This is known as a â€œtimeoutâ€.</p>

<p>Had the â€œdestination unreachableâ€ packet made it back to you, you would know that there was a problem with the destination and your computer would give up instantaneously on that connection. You, or your application, would not be forced to wait (sometimes up to 60 seconds, or more!)Â for the connection to â€œtimeoutâ€.</p>

<p>Another important ICMP packet that could be discarded by the filter is an â€œICMP FRAGMENTATION REQUIREDâ€ message. When that happens, things start to go really wrong.</p>

<h4 id="fragmentation-whats-that">Fragmentation? Whatâ€™s that?</h4>

<p>So far weâ€™ve seen the consequences of trying to talk to an unreachable host - whilst timeouts are inconvenient in that case, they are only masking another issue. However, blocking ICMP may even stop you from being able to communicate with reachable hosts too!</p>

<p>The key to this is that not all network links are created equal. To understand why, a bit of Layer 2 knowledge is required. In Ethernet land, a single â€œframeâ€ of data (that is, a frame containing an IP packet) can only be so big. The default maximum frame size for an Ethernet network is 1500 bytes. Once you go above 1500 bytes, you have to create a new frame to send the next 1500 bytes. And so on, and so forth. To stream a large amount of information, you may send hundreds, thousands, or even hundreds of thousands of frames.Â </p>

<p>Of course not all network links are based solely on Ethernet. Many broadband providers rely on a protocol called PPP to establish your connection across their network to the Internet, as this provides them with the extra authentication capability to identify you as a specific customer. PPP has additional headers, and when also wrapped in an Ethernet frame (this is known as PPPoE), means that there is less space available for your IP packet. Therefore 1500 bytes actually becomes 1492 bytes when you include the additional room needed to â€œfitâ€ PPP onto the pipe.</p>

<p>This number - whether 1500, 1492 or any arbitrary number of bytes - is known as the â€œMaximum Transmission Unitâ€, or MTU, and network devices must be aware of the MTU of a given link so that it does not produce frames too big for that link.</p>

<p>What happens when you send a frame thatâ€™s 1500 bytes down a link that only supports frames of 1492 bytes? You guessed it - it wonâ€™t fit. At this point, a router on the path has received a frame from a link where the MTU is 1500, and has tried to send it back out of another interface where the MTU is 1492.</p>

<p>Logically this is an impossible situation, so the router simply discards the frame and sends back a â€œfragmentation requiredâ€ ICMP message back to the sender to say â€œThis packet is too big for where youâ€™re trying to send it, so please make it smallerâ€. The sending computer can then break down the packet into smaller chunks and resend them so that theyâ€™ll now fit down the link.Â </p>

<p>The sending computer will also â€œlearnâ€ from this ICMP message,Â temporarily remembering this condition for that given destination address, so the next packets that get sent will not exceed the given MTU size, avoiding the problem and allowing seamless communication back and forth.Â </p>

<h4 id="so-if-the-sender-never-gets-the-fragmentation-required-packet">So if the sender never gets the â€œfragmentation requiredâ€ packetâ€¦</h4>

<p>â€¦ then the router on the path will discard the packet thatâ€™s too big, itâ€™ll send an ICMP message back to you asking you to send smaller packets instead, that ICMP message will be blocked by your firewall and you will never get that memo, therefore your computer assumes that everything was fine.</p>

<p>In reality, it isnâ€™t fine because your packet was discarded by an upstream router so it simply never got there, and you never found out why because the warning ICMP packet was discarded before it got to you, therefore you sit and wait yet again until the â€œtimeoutâ€ with absolutely no clue as to whether the data you sent actually got there or not.Â </p>

<p>This is loosely known as â€œPath MTU discoveryâ€, and is a core feature of IP, to ensure that larger packets can be sent across different types of network link without too much trouble. By blocking ICMP, you are completely removing the computerâ€™s ability to learn about these conditions, creating unstable connectivity to that destination.Â </p>

<h4 id="okay-so-why-do-people-claim-its-such-a-security-problem">Okay, so why do people claim itâ€™s such a security problem?</h4>

<p>There are some legitimate reasons for believing that ICMP is a security issue, and there are plenty of outright myths.</p>

<p>One real problem is that â€œICMP ECHOâ€ packets (those used for â€œpingâ€) can actually contain any arbitrary amount of information of pretty much any kind, which makes them useful for tunnelling packets inside â€œICMP ECHOsâ€ to avoid network boundary filtering using specialised software for this purpose. The reality of this is that most people are completely unaware that this is even a possibility, and some more intelligent firewalls may even be able to identify when this is happening.</p>

<p>Another is that â€œICMP ECHOâ€ actually reveals the existence of a device on the end of a given IP address very easily. The reality is that there are actually plenty of other ways to determine this, therefore this is a bit of a non-issue. Knowing that a machine exists doesnâ€™t really help you all that much - ICMP doesnâ€™t provide you with a â€œbackdoorâ€. You would still need some other route in by means of other open ports, and those open ports are just as likely to reveal the existence of the machine as â€œpingâ€ is.Â </p>

<p>Some are concerned that the â€œICMP TTL EXCEEDEDâ€ packets may actually reveal the existence of routers on a path between two given hosts. This is actually the basis for how â€œtracerouteâ€ functions - send multiple packets with deliberately incremental TTL values, allow them to expire in transit and capture which routers report back with the â€œICMP TTL EXCEEDEDâ€ warning.</p>

<p>Overly security-conscious individuals would prefer not to reveal the existence of things because it provides a kind of â€œsecurity through obscurityâ€, and therefore will just block all ICMP, not understanding that it has many functions outside of â€œICMP ECHOâ€. This is sadly a real world knowledge gap for a lot of IT professionals.</p>

<h4 id="but-i-really-really-dont-want-people-to-be-able-to-ping-devices-in-my-network">But I really really donâ€™t want people to be able to ping devices in my network.</h4>

<p>Okay. In which case, what you need is to actually configure your firewall properlyÂ so that rather than blocking all ICMP traffic, you just simply block ICMP traffic with the specific type codes relative to â€œpingâ€. For your information, those are â€œICMP ECHO REPLYâ€ (type code 0) and â€œICMP ECHO REQUESTâ€ (type code 8).Â </p>

<p>That way, other diagnostic traffic, such as â€œICMP DESTINATION UNREACHABLEâ€ (type code 3) or â€œICMP TTL EXCEEDEDâ€ (type code 11) will still be allowed through, and your computers will be able to learn about network problems properly. Hooray!</p>

<p>If you were particularly concerned about not revealing the existence of routers by means of â€œICMP TTL EXCEEDEDâ€ (type code 11), then this specific message type could be filtered without too much ill-effect, at the expense of creating timeouts in genuine circumstances, i.e. when attempting to reconstruct fragmented packets or dropping packets where the TTL field has reached zero.</p>

<h4 id="what-else-should-i-know-about-icmp">What else should I know about ICMP?</h4>

<p>The problem is that even blocking â€œpingâ€ can be bad in some scenarios - some software may use this mechanism to see if a host is available before trying to speak to it.</p>

<p>An extremely widely used example of this is Active Directory for domain-joined Windows clients, where ICMP is used to perform â€œslow link detectionâ€ before downloading and applying Group Policy Objects (GPOs). For more information on the consequences of ICMP on Active Directory, take a look at TechNet. Seeing problems with GPOs applying at logon? This might be related.</p>

<p>The other thing to be aware of is that ICMP is typically classed as â€œlow priorityâ€ traffic by many routers and firewalls. That is, these devices should not prioritise ICMP traffic over typical IP traffic, therefore ICMP should really have little-to-no negative impact on the throughput of your network.Â However, if you were conscious about whether or not your network could be flooded with ICMP traffic, you can safely rate-limit ICMP, so long as you are not throttling it down so much that the ICMP packets end up being dropped regardless.Â </p>

<h4 id="in-conclusion">In conclusionâ€¦</h4>

<p>â€¦ thereâ€™s a lot more to ICMP than initially meets the eye, and there are very real cases where ICMP is needed. Donâ€™t take the decision to block it outright lightly.</p>
:ET